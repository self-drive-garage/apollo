/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: CANDBCMessage.idl
  Source: CANDBCMessage.hpp
  Cyclone DDS: v0.10.5

*****************************************************************/
#ifndef DDSCXX_CANDBCMESSAGE_HPP
#define DDSCXX_CANDBCMESSAGE_HPP

#include "platform/io/can/CAN.hpp"

#include <cstdint>
#include <string>
#include <vector>

namespace platform {
namespace io {
namespace can {
namespace dbc {
class CANDBCSignal
{
private:
    uint64_t timestampNanoSeconds_ = 0;
    std::string timestampReadable_;
    std::string name_;
    double value_ = 0.0;
    bool isLittleEndian_ = true;

public:
    CANDBCSignal() = default;

    explicit CANDBCSignal(const uint64_t timestampNanoSeconds,
                          const std::string& name,
                          const double value,
                          const bool isLittleEndian)
        : timestampNanoSeconds_(timestampNanoSeconds)
        , name_(name)
        , value_(value)
        , isLittleEndian_(isLittleEndian)
    {}

    uint64_t timestampNanoSeconds() const { return this->timestampNanoSeconds_; }
    uint64_t& timestampNanoSeconds() { return this->timestampNanoSeconds_; }
    void timestampNanoSeconds(const uint64_t _val_) { this->timestampNanoSeconds_ = _val_; }
    std::string timestampReadable() const { return this->timestampReadable_; }
    std::string& timestampReadable() { return this->timestampReadable_; }
    void timestampReadable(std::string _val_) { this->timestampReadable_ = std::move(_val_); }
    const std::string& name() const { return this->name_; }
    std::string& name() { return this->name_; }
    void name(const std::string& _val_) { this->name_ = _val_; }
    void name(std::string&& _val_) { this->name_ = _val_; }
    double value() const { return this->value_; }
    double& value() { return this->value_; }
    void value(double _val_) { this->value_ = _val_; }
    bool isLittleEndian() const { return this->isLittleEndian_; }
    void isLittleEndian(const bool littleEndian) { this->isLittleEndian_ = littleEndian; }

    bool operator==(const CANDBCSignal& _other) const
    {
        (void)_other;
        return timestampNanoSeconds_ == _other.timestampNanoSeconds_ && name_ == _other.name_ &&
               value_ == _other.value_;
    }

    bool operator!=(const CANDBCSignal& _other) const { return !(*this == _other); }
};

class CANDBCMessage
{
private:
    uint32_t address_ = 0;
    std::string name_;
    ::platform::io::can::CANBus canBus_ = ::platform::io::can::CANBus::MAIN_BUS;
    std::vector<::platform::io::can::dbc::CANDBCSignal> signals_;

public:
    CANDBCMessage() = default;

    explicit CANDBCMessage(const uint32_t address)
        : address_(address)
        , signals_({})
    {}

    explicit CANDBCMessage(uint32_t address,
                           const std::string& name,
                           ::platform::io::can::CANBus canBus,
                           const std::vector<::platform::io::can::dbc::CANDBCSignal>& signals)
        : address_(address)
        , name_(name)
        , canBus_(canBus)
        , signals_(signals)
    {}

    uint32_t address() const { return this->address_; }
    uint32_t& address() { return this->address_; }
    void address(uint32_t _val_) { this->address_ = _val_; }
    const std::string& name() const { return this->name_; }
    std::string& name() { return this->name_; }
    void name(const std::string& _val_) { this->name_ = _val_; }
    void name(std::string&& _val_) { this->name_ = _val_; }
    ::platform::io::can::CANBus canBus() const { return this->canBus_; }
    ::platform::io::can::CANBus& canBus() { return this->canBus_; }
    void canBus(::platform::io::can::CANBus _val_) { this->canBus_ = _val_; }
    const std::vector<::platform::io::can::dbc::CANDBCSignal>& signals() const { return this->signals_; }
    std::vector<::platform::io::can::dbc::CANDBCSignal>& signals() { return this->signals_; }
    void signals(const std::vector<::platform::io::can::dbc::CANDBCSignal>& _val_) { this->signals_ = _val_; }
    void signals(std::vector<::platform::io::can::dbc::CANDBCSignal>&& _val_) { this->signals_ = _val_; }
    void addSignal(::platform::io::can::dbc::CANDBCSignal&& signal) { this->signals_.emplace_back(signal); }

    bool operator==(const CANDBCMessage& _other) const
    {
        (void)_other;
        return address_ == _other.address_ && name_ == _other.name_ && canBus_ == _other.canBus_ &&
               signals_ == _other.signals_;
    }

    bool operator!=(const CANDBCMessage& _other) const { return !(*this == _other); }

    /// @brief Gets the CAN bus of the message.
    /// @return The CAN bus of the message.
    std::string getCanBus() const
    {
        switch (canBus_) {
            case CANBus::MAIN_BUS:
                return "MAIN_BUS";
            case CANBus::ALT_BUS:
                return "ALT_BUS";
            case CANBus::CAMERA_BUS:
                return "CAMERA_BUS";
            default:
                return "UNKNOWN_BUS";
        }
    }
};

} // namespace dbc
} // namespace can
} // namespace io
} // namespace platform

#include "dds/topic/TopicTraits.hpp"
#include "org/eclipse/cyclonedds/topic/datatopic.hpp"

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace topic {

template<>
constexpr const char* TopicTraits<::platform::io::can::dbc::CANDBCSignal>::getTypeName()
{
    return "platform::io::can::dbc::CANDBCSignal";
}

template<>
constexpr bool TopicTraits<::platform::io::can::dbc::CANDBCSignal>::isSelfContained()
{
    return false;
}

template<>
constexpr bool TopicTraits<::platform::io::can::dbc::CANDBCSignal>::isKeyless()
{
    return true;
}

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template<>
constexpr unsigned int TopicTraits<::platform::io::can::dbc::CANDBCSignal>::type_map_blob_sz()
{
    return 314;
}
template<>
constexpr unsigned int TopicTraits<::platform::io::can::dbc::CANDBCSignal>::type_info_blob_sz()
{
    return 100;
}
template<>
inline const uint8_t* TopicTraits<::platform::io::can::dbc::CANDBCSignal>::type_map_blob()
{
    static const uint8_t blob[] = {
        0x5b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f, 0xbf, 0xd2, 0xdb, 0xca,
        0xba, 0x5b, 0x32, 0x84, 0x13, 0x00, 0x43, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x08, 0x72, 0x33, 0x59, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x70, 0x00, 0xb0, 0x68, 0x93, 0x1c, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x0a, 0x20, 0x63, 0xc1, 0x60, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x25, 0x05, 0x5f,
        0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67, 0xe5, 0x69, 0x28, 0x06, 0x54, 0x00, 0x98, 0x00, 0x00, 0x00, 0xf2, 0x51,
        0x01, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x70, 0x6c, 0x61, 0x74,
        0x66, 0x6f, 0x72, 0x6d, 0x3a, 0x3a, 0x69, 0x6f, 0x3a, 0x3a, 0x63, 0x61, 0x6e, 0x3a, 0x3a, 0x64, 0x62, 0x63,
        0x3a, 0x3a, 0x43, 0x41, 0x4e, 0x44, 0x42, 0x43, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x00, 0x00, 0x00, 0x00,
        0x5c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x08, 0x00, 0x15, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x4e, 0x61, 0x6e,
        0x6f, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x05, 0x00, 0x00, 0x00, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x06, 0x00, 0x00, 0x00, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x25, 0x05, 0x5f,
        0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67, 0xe5, 0x69, 0x28, 0x06, 0x54, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f, 0xbf,
        0xd2, 0xdb, 0xca, 0xba, 0x5b, 0x32, 0x84, 0x13,
    };
    return blob;
}
template<>
inline const uint8_t* TopicTraits<::platform::io::can::dbc::CANDBCSignal>::type_info_blob()
{
    static const uint8_t blob[] = {
        0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14,
        0x00, 0x00, 0x00, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f, 0xbf, 0xd2, 0xdb, 0xca, 0xba, 0x5b, 0x32, 0x84,
        0x13, 0x00, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf2, 0x25, 0x05, 0x5f, 0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67, 0xe5, 0x69, 0x28, 0x06, 0x54, 0x00, 0x9c,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif // DDSCXX_HAS_TYPE_DISCOVERY

template<>
constexpr const char* TopicTraits<::platform::io::can::dbc::CANDBCMessage>::getTypeName()
{
    return "platform::io::can::dbc::CANDBCMessage";
}

template<>
constexpr bool TopicTraits<::platform::io::can::dbc::CANDBCMessage>::isSelfContained()
{
    return false;
}

template<>
constexpr bool TopicTraits<::platform::io::can::dbc::CANDBCMessage>::isKeyless()
{
    return true;
}

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template<>
constexpr unsigned int TopicTraits<::platform::io::can::dbc::CANDBCMessage>::type_map_blob_sz()
{
    return 1010;
}
template<>
constexpr unsigned int TopicTraits<::platform::io::can::dbc::CANDBCMessage>::type_info_blob_sz()
{
    return 196;
}
template<>
inline const uint8_t* TopicTraits<::platform::io::can::dbc::CANDBCMessage>::type_map_blob()
{
    static const uint8_t blob[] = {
        0x4b, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf1, 0xca, 0x30, 0x81, 0x90, 0xd8, 0xc0, 0xea, 0x39, 0x37,
        0x22, 0x14, 0xf9, 0xe8, 0xeb, 0x00, 0x76, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x07, 0x88, 0x4d, 0x98, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x70, 0x00, 0xb0, 0x68, 0x93, 0x1c, 0x19, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00,
        0xf1, 0x04, 0x11, 0x97, 0x09, 0x8e, 0x86, 0x85, 0x8f, 0x8d, 0x97, 0x82, 0x0a, 0x3d, 0x65, 0x79, 0x85, 0x87,
        0x3f, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0xf1, 0x01, 0x00,
        0x00, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f, 0xbf, 0xd2, 0xdb, 0xca, 0xba, 0x5b, 0x32, 0x84, 0x13, 0xa8, 0x42,
        0x0f, 0x8b, 0xf1, 0x04, 0x11, 0x97, 0x09, 0x8e, 0x86, 0x85, 0x8f, 0x8d, 0x97, 0x82, 0x0a, 0x3d, 0x65, 0x00,
        0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
        0x3e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x5a, 0xef, 0x08, 0xa5, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0xff, 0x46, 0x3d, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x96, 0x85, 0xb3, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f,
        0xbf, 0xd2, 0xdb, 0xca, 0xba, 0x5b, 0x32, 0x84, 0x13, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0xf1, 0x51,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x72, 0x33, 0x59, 0x30, 0x00, 0x0c, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xb0, 0x68, 0x93, 0x1c, 0x0b, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x20, 0x63, 0xc1, 0x60, 0x00, 0x3c, 0x02, 0x00, 0x00, 0x03, 0x00,
        0x00, 0x00, 0xf2, 0xe1, 0xa3, 0x73, 0x8f, 0xf4, 0xb5, 0xb5, 0x89, 0xc5, 0xef, 0x0e, 0x85, 0x7b, 0x08, 0x00,
        0xce, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00,
        0x00, 0x00, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x3a, 0x3a, 0x69, 0x6f, 0x3a, 0x3a, 0x63, 0x61,
        0x6e, 0x3a, 0x3a, 0x64, 0x62, 0x63, 0x3a, 0x3a, 0x43, 0x41, 0x4e, 0x44, 0x42, 0x43, 0x4d, 0x65, 0x73, 0x73,
        0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
        0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x01, 0x00, 0xf2, 0xe5, 0x5d, 0xcb, 0x0a, 0x2f, 0x7d, 0x37, 0xef, 0xe3, 0x0f, 0xbc, 0xaf, 0x5e,
        0x43, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x63, 0x61, 0x6e, 0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0xf2, 0x01, 0x00, 0x00, 0xf2,
        0x25, 0x05, 0x5f, 0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67, 0xe5, 0x69, 0x28, 0x06, 0x54, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x00, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x73, 0x00, 0x00, 0x00, 0xf2, 0xe5, 0x5d, 0xcb, 0x0a, 0x2f,
        0x7d, 0x37, 0xef, 0xe3, 0x0f, 0xbc, 0xaf, 0x5e, 0x43, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xf2, 0x40,
        0x01, 0x00, 0x22, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x70, 0x6c, 0x61, 0x74,
        0x66, 0x6f, 0x72, 0x6d, 0x3a, 0x3a, 0x69, 0x6f, 0x3a, 0x3a, 0x63, 0x61, 0x6e, 0x3a, 0x3a, 0x43, 0x41, 0x4e,
        0x42, 0x75, 0x73, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x43, 0x41,
        0x4e, 0x42, 0x75, 0x73, 0x5f, 0x41, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x43, 0x41, 0x4e, 0x42, 0x75, 0x73,
        0x5f, 0x42, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x43, 0x41, 0x4e, 0x42, 0x75, 0x73, 0x5f, 0x43, 0x00, 0x00,
        0x00, 0xf2, 0x25, 0x05, 0x5f, 0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67, 0xe5, 0x69, 0x28, 0x06, 0x54, 0x00, 0x00,
        0x98, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00,
        0x00, 0x00, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x3a, 0x3a, 0x69, 0x6f, 0x3a, 0x3a, 0x63, 0x61,
        0x6e, 0x3a, 0x3a, 0x64, 0x62, 0x63, 0x3a, 0x3a, 0x43, 0x41, 0x4e, 0x44, 0x42, 0x43, 0x53, 0x69, 0x67, 0x6e,
        0x61, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x15, 0x00, 0x00, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x4e, 0x61, 0x6e, 0x6f, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x00, 0x00, 0x00, 0x00,
        0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x05, 0x00, 0x00, 0x00, 0x6e, 0x61,
        0x6d, 0x65, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x03, 0x00,
        0x00, 0x00, 0xf2, 0xe1, 0xa3, 0x73, 0x8f, 0xf4, 0xb5, 0xb5, 0x89, 0xc5, 0xef, 0x0e, 0x85, 0x7b, 0x08, 0xf1,
        0xca, 0x30, 0x81, 0x90, 0xd8, 0xc0, 0xea, 0x39, 0x37, 0x22, 0x14, 0xf9, 0xe8, 0xeb, 0xf2, 0xe5, 0x5d, 0xcb,
        0x0a, 0x2f, 0x7d, 0x37, 0xef, 0xe3, 0x0f, 0xbc, 0xaf, 0x5e, 0x43, 0xf1, 0x04, 0x11, 0x97, 0x09, 0x8e, 0x86,
        0x85, 0x8f, 0x8d, 0x97, 0x82, 0x0a, 0x3d, 0x65, 0xf2, 0x25, 0x05, 0x5f, 0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67,
        0xe5, 0x69, 0x28, 0x06, 0x54, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f, 0xbf, 0xd2, 0xdb, 0xca, 0xba, 0x5b, 0x32,
        0x84, 0x13,
    };
    return blob;
}
template<>
inline const uint8_t* TopicTraits<::platform::io::can::dbc::CANDBCMessage>::type_info_blob()
{
    static const uint8_t blob[] = {
        0xc0, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x14, 0x00,
        0x00, 0x00, 0xf1, 0xca, 0x30, 0x81, 0x90, 0xd8, 0xc0, 0xea, 0x39, 0x37, 0x22, 0x14, 0xf9, 0xe8, 0xeb, 0x00,
        0x7a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00,
        0x00, 0x00, 0xf1, 0x04, 0x11, 0x97, 0x09, 0x8e, 0x86, 0x85, 0x8f, 0x8d, 0x97, 0x82, 0x0a, 0x3d, 0x65, 0x00,
        0x52, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x42, 0x06, 0x06, 0xaa, 0x7f, 0xbf, 0xd2, 0xdb, 0xca,
        0xba, 0x5b, 0x32, 0x84, 0x13, 0x00, 0x47, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00,
        0x54, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xe1, 0xa3, 0x73, 0x8f, 0xf4, 0xb5, 0xb5, 0x89, 0xc5,
        0xef, 0x0e, 0x85, 0x7b, 0x08, 0x00, 0xd2, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xe5, 0x5d, 0xcb, 0x0a, 0x2f, 0x7d, 0x37, 0xef, 0xe3,
        0x0f, 0xbc, 0xaf, 0x5e, 0x43, 0x00, 0x97, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x25, 0x05, 0x5f,
        0x20, 0x68, 0x14, 0x0d, 0xa6, 0x67, 0xe5, 0x69, 0x28, 0x06, 0x54, 0x00, 0x9c, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif // DDSCXX_HAS_TYPE_DISCOVERY

} // namespace topic
} // namespace cyclonedds
} // namespace eclipse
} // namespace org

namespace dds {
namespace topic {

template<>
struct topic_type_name<::platform::io::can::dbc::CANDBCSignal>
{
    static std::string value()
    {
        return org::eclipse::cyclonedds::topic::TopicTraits<::platform::io::can::dbc::CANDBCSignal>::getTypeName();
    }
};

template<>
struct topic_type_name<::platform::io::can::dbc::CANDBCMessage>
{
    static std::string value()
    {
        return org::eclipse::cyclonedds::topic::TopicTraits<::platform::io::can::dbc::CANDBCMessage>::getTypeName();
    }
};

} // namespace topic
} // namespace dds

REGISTER_TOPIC_TYPE(::platform::io::can::dbc::CANDBCSignal)
REGISTER_TOPIC_TYPE(::platform::io::can::dbc::CANDBCMessage)

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace core {
namespace cdr {

template<>
::platform::io::can::CANBus enum_conversion<::platform::io::can::CANBus>(uint32_t in);

template<>
propvec& get_type_props<::platform::io::can::dbc::CANDBCSignal>();

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T& streamer, const ::platform::io::can::dbc::CANDBCSignal& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!write(streamer, instance.timestampNanoSeconds()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!write_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!write(streamer, instance.value()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S& str, const ::platform::io::can::dbc::CANDBCSignal& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCSignal>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T& streamer, ::platform::io::can::dbc::CANDBCSignal& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!read(streamer, instance.timestampNanoSeconds()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!read_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!read(streamer, instance.value()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S& str, ::platform::io::can::dbc::CANDBCSignal& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCSignal>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T& streamer, const ::platform::io::can::dbc::CANDBCSignal& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!move(streamer, instance.timestampNanoSeconds()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!move_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!move(streamer, instance.value()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S& str, const ::platform::io::can::dbc::CANDBCSignal& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCSignal>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T& streamer, const ::platform::io::can::dbc::CANDBCSignal& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!max(streamer, instance.timestampNanoSeconds()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!max_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!max(streamer, instance.value()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S& str, const ::platform::io::can::dbc::CANDBCSignal& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCSignal>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template<>
propvec& get_type_props<::platform::io::can::dbc::CANDBCMessage>();

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T& streamer, const ::platform::io::can::dbc::CANDBCMessage& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!write(streamer, instance.address()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!write_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!write(streamer, instance.canBus()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 3:
                if (!streamer.start_member(*prop))
                    return false;
                if (!streamer.start_consecutive(false, false))
                    return false;
                {
                    uint32_t se_1 = uint32_t(instance.signals().size());
                    if (!write(streamer, se_1))
                        return false;
                    for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                        if (!write(streamer, instance.signals()[i_1], prop))
                            return false;
                    } // i_1
                }     // end sequence 1
                if (!streamer.finish_consecutive())
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S& str, const ::platform::io::can::dbc::CANDBCMessage& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCMessage>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T& streamer, ::platform::io::can::dbc::CANDBCMessage& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!read(streamer, instance.address()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!read_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!read(streamer, instance.canBus()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 3:
                if (!streamer.start_member(*prop))
                    return false;
                if (!streamer.start_consecutive(false, false))
                    return false;
                {
                    uint32_t se_1 = uint32_t(instance.signals().size());
                    if (!read(streamer, se_1))
                        return false;
                    instance.signals().resize(se_1);
                    for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                        if (!read(streamer, instance.signals()[i_1], prop))
                            return false;
                    } // i_1
                }     // end sequence 1
                if (!streamer.finish_consecutive())
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S& str, ::platform::io::can::dbc::CANDBCMessage& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCMessage>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T& streamer, const ::platform::io::can::dbc::CANDBCMessage& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!move(streamer, instance.address()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!move_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!move(streamer, instance.canBus()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 3:
                if (!streamer.start_member(*prop))
                    return false;
                if (!streamer.start_consecutive(false, false))
                    return false;
                {
                    uint32_t se_1 = uint32_t(instance.signals().size());
                    if (!move(streamer, se_1))
                        return false;
                    for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                        if (!move(streamer, instance.signals()[i_1], prop))
                            return false;
                    } // i_1
                }     // end sequence 1
                if (!streamer.finish_consecutive())
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S& str, const ::platform::io::can::dbc::CANDBCMessage& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCMessage>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T& streamer, const ::platform::io::can::dbc::CANDBCMessage& instance, entity_properties_t* props)
{
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
            case 0:
                if (!streamer.start_member(*prop))
                    return false;
                if (!max(streamer, instance.address()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 1:
                if (!streamer.start_member(*prop))
                    return false;
                if (!max_string(streamer, instance.name(), 0))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 2:
                if (!streamer.start_member(*prop))
                    return false;
                if (!max(streamer, instance.canBus()))
                    return false;
                if (!streamer.finish_member(*prop))
                    return false;
                break;
            case 3:
                if (!streamer.start_member(*prop))
                    return false;
                if (!streamer.start_consecutive(false, false))
                    return false;
                {
                    uint32_t se_1 = 0;
                    if (!max(streamer, se_1))
                        return false;
                    for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                        if (!max(streamer, instance.signals()[i_1], prop))
                            return false;
                    } // i_1
                }     // end sequence 1
                if (!streamer.finish_consecutive())
                    return false;
                streamer.position(SIZE_MAX);
                if (!streamer.finish_member(*prop))
                    return false;
                break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S& str, const ::platform::io::can::dbc::CANDBCMessage& instance, bool as_key)
{
    auto& props = get_type_props<::platform::io::can::dbc::CANDBCMessage>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

} // namespace cdr
} // namespace core
} // namespace cyclonedds
} // namespace eclipse
} // namespace org

#endif // DDSCXX_CANDBCMESSAGE_HPP
